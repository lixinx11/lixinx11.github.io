<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello world</title>
    <url>/2010/04/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>Hello world</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown</title>
    <url>/2020/08/18/markdown/</url>
    <content><![CDATA[<h2 id="pandoc的安装"><a href="#pandoc的安装" class="headerlink" title="pandoc的安装"></a>pandoc的安装</h2><p>pandoc的作用主要是将我们的markdown文件转换成html，<br>这样就可以在浏览器中实时预览我们的文件渲染效果。<br>当然，pandoc还有许多其他的功能，比如它也支持将markdown文件输出成pdf等，给出他的下载链接</p>
<h3 id="网址：http-pandoc-org-installing-html"><a href="#网址：http-pandoc-org-installing-html" class="headerlink" title="网址：http://pandoc.org/installing.html"></a>网址：<a href="http://pandoc.org/installing.html">http://pandoc.org/installing.html</a></h3>]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql5.7安装使用指南</title>
    <url>/2020/08/15/mysql%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-1/</url>
    <content><![CDATA[<h2 id="1、加压mysql文件包，并在D-mysql5-7-28-目录下创建my-ini"><a href="#1、加压mysql文件包，并在D-mysql5-7-28-目录下创建my-ini" class="headerlink" title="1、加压mysql文件包，并在D:\mysql5.7.28 目录下创建my.ini"></a>1、加压mysql文件包，并在D:\mysql5.7.28 目录下创建my.ini</h2><p>内容：</p>
<p>[client]</p>
<h1 id="设置mysql客户端默认字符集"><a href="#设置mysql客户端默认字符集" class="headerlink" title="设置mysql客户端默认字符集"></a>设置mysql客户端默认字符集</h1><p>default-character-set=utf8</p>
<p>[mysqld]</p>
<h1 id="设置3306端口"><a href="#设置3306端口" class="headerlink" title="设置3306端口"></a>设置3306端口</h1><p>port = 3306<br>character-set-server=utf8</p>
<h1 id="设置mysql的安装目录"><a href="#设置mysql的安装目录" class="headerlink" title="设置mysql的安装目录"></a>设置mysql的安装目录</h1><p>basedir=D:\mysql5.7.28</p>
<h1 id="设置-mysql数据库的数据的存放目录，MySQL-8-不需要以下配置，系统自己生成即可，否则有可能报错"><a href="#设置-mysql数据库的数据的存放目录，MySQL-8-不需要以下配置，系统自己生成即可，否则有可能报错" class="headerlink" title="设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错"></a>设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错</h1><p>#datadir=D:\mysql5.7.28\data</p>
<h1 id="允许最大连接数"><a href="#允许最大连接数" class="headerlink" title="允许最大连接数"></a>允许最大连接数</h1><p>max_connections=200</p>
<h1 id="服务端使用的字符集默认为8比特编码的latin1字符集"><a href="#服务端使用的字符集默认为8比特编码的latin1字符集" class="headerlink" title="服务端使用的字符集默认为8比特编码的latin1字符集"></a>服务端使用的字符集默认为8比特编码的latin1字符集</h1><p>character-set-server=utf8</p>
<h1 id="创建新表时将使用的默认存储引擎"><a href="#创建新表时将使用的默认存储引擎" class="headerlink" title="创建新表时将使用的默认存储引擎"></a>创建新表时将使用的默认存储引擎</h1><p>default-storage-engine=INNODB<br>sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</p>
<h2 id="2、以管理员身份安装并且启动-cmd"><a href="#2、以管理员身份安装并且启动-cmd" class="headerlink" title="2、以管理员身份安装并且启动 cmd"></a>2、以管理员身份安装并且启动 cmd</h2><p>mysqld  –initialize    – 此步骤会自动生成data文件包</p>
<p>初始化成功后会在my.ini配置文件的datadir的目录下生成一些文件，其中xxx.err(xxx是你电脑用户的名称)文件里说明了root账户的临时密码。例子：&lt;r8j<em>Qrh)jdp就是root账户的临时密码<br> A temporary password is generated for root@localhost: &lt;r8j</em>Qrh)jdp  eqncDQIUl8/P</p>
<h2 id="3、注册mysql服务"><a href="#3、注册mysql服务" class="headerlink" title="3、注册mysql服务"></a>3、注册mysql服务</h2><p>mysqld -install MySQL </p>
<h2 id="4、启动mysql服务"><a href="#4、启动mysql服务" class="headerlink" title="4、启动mysql服务"></a>4、启动mysql服务</h2><p>net start MySQL  </p>
<p>使用root账号登录</p>
<p>mysql -u root -p eqncDQIUl8/P</p>
<p>修改root密码</p>
<p>ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘root’;  </p>
<p>完整操作步骤<br>以非管理员身份安装数据库提示拒绝安装<br>以管理员身份安装并且启动<br>配置环境变量，便于以后不需进入安装路径才能调用sql.exe</p>
<p>· 添加一个名叫 MYSQL_HOME 的变量</p>
<p>· 修改Path变量，在末尾添加 %MYSQL_HOME%\bin</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>我的技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2012/03/15/mysql%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>   第一章</p>
<p>内容</p>
<hr>
<p> 第二章</p>
<p>内容</p>
<hr>
<p>   参考文献</p>
<p><a href="http://www.baidu.com/">www.baidu.com</a></p>
]]></content>
  </entry>
  <entry>
    <title>大数据技术栈</title>
    <url>/2020/05/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
    <content><![CDATA[<p><img src="https://lixinx11.github.io/medias/bigdata/1.png" alt="大数据架构"></p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>我的技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title>redis使用指南</title>
    <url>/2018/06/13/redis%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>redis与redis部署服务的安装<br>下载文件redis-3.0.0.tar.gz</p>
<h2 id="一，redis服务的安装"><a href="#一，redis服务的安装" class="headerlink" title="一，redis服务的安装"></a>一，redis服务的安装</h2><h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h3><p>Redis是c开发的，因此安装redis需要c语言的编译环境，即需要安装gcc</p>
<p>查看是否安装gcc</p>
<p>gcc -v<br>如果没有gcc，则需要在线安装。命令如下</p>
<p>yum install gcc-c++</p>
<h3 id="2-redis安装"><a href="#2-redis安装" class="headerlink" title="2.redis安装"></a>2.redis安装</h3><p>1）上传redis压缩包到服务器</p>
<p>本文是通过MobaXterm进行操作的，如图</p>
<p>1.png 2）解压redis压缩包</p>
<p>tar zxf redis-3.0.0.tar.gz<br>3）进入redis-3.0.0目录并查看该目录下文件</p>
<p>2.png</p>
<p>4）制作编译redis源码</p>
<p>3.png</p>
<p>如下则编译成功</p>
<p>4.png</p>
<p>5）安装编译后的redis代码到指定目录，一般存放于/ usr / local下的redis目录，指令如下</p>
<p>make install PREFIX=/usr/local/redis<br>如下图则说明安装成功，此时查看/ user / local目录，可以发现多了一个redis文件夹</p>
<p>5.png</p>
<p>6）此时可以启动redis了，交替启动模式为前端启动，指令如下</p>
<p>./redis-server<br>6.png</p>
<p>7）前端启动的话，如果客户端关闭，redis服务也会停掉，所以需要改成后台启动redis</p>
<p>a）将redis解压文件里面的redis.conf文件复制到当前目录</p>
<p>cp ~/redis-3.0.0/redis.conf .<br>b）修改redis.conf文件，将守护进程否-&gt;将守护进程守护进程，这样便将启动方式修改为后台启动了</p>
<p>vim redis.conf<br>7.png</p>
<p>然后保存修改并退出，指令如下（四步操作）</p>
<p>Esc -&gt; : -&gt; wq -&gt; Enter(回车)</p>
<h3 id="3-启动redis（后台启动）"><a href="#3-启动redis（后台启动）" class="headerlink" title="3.启动redis（后台启动）"></a>3.启动redis（后台启动）</h3><p>./redis-server redis.conf<br>8.png</p>
<p>4.测试<br>1）查看redis是否在运行</p>
<p>ps aux|grep redis<br>2）打开redis连接</p>
<p>./redis-cli   或redis-cli -c -p 6379<br>连接成功，如图所示</p>
<p>9.png</p>
<h2 id="二，redis实施服务安装"><a href="#二，redis实施服务安装" class="headerlink" title="二，redis实施服务安装"></a>二，redis实施服务安装</h2><h3 id="1-创建重新分配目录"><a href="#1-创建重新分配目录" class="headerlink" title="1.创建重新分配目录"></a>1.创建重新分配目录</h3><p>1）在usr / local目录下新建的redis-cluster目录，用于存放重新分配</p>
<p>10.png</p>
<p>2）复制/ usr / local / redis / bin目录下所有文件</p>
<p>把redis目录下的bin目录下的所有文件复制到/ usr / local / redis-cluster / redis01目录下，不用担心这里没有redis01目录，会自动创建的。</p>
<p>cp -r redis/bin/ redis-cluster/redis01<br>11.png</p>
<p>3）删除redis01目录下快照文件dump.rdb。</p>
<p>rm -rf dump.rdb<br>12.png</p>
<p>4）修改redis01目录下redis.conf配置文件</p>
<p>a）修改端口号为6380</p>
<p>13.png</p>
<p>b）将启用群集功能是的注释打开（大概632行）</p>
<p>c）将群集配置文件节点6379.conf的注释打开，并同时将群集配置文件节点6380.conf（大概640行）</p>
<p>14.png</p>
<p>d）打开bind注释，并修改为bind 192.168.0.40（这一步很重要，每个例程都要修改为对应的服务器的ip，下面127.0.0.1的地方都要替换192.168.0.40）</p>
<p>5）创建6个redis实例</p>
<p>a）将redis-cluster / redis01文件复制5份到redis-cluster目录下（redis02-redis06），创建6个redis实例，模拟Redis替换的6个实例。如下所示：</p>
<p>15.png</p>
<p>b）分别修改redis.conf文件端口号为6381-6385</p>
<h3 id="2-启动所有redis例程"><a href="#2-启动所有redis例程" class="headerlink" title="2.启动所有redis例程"></a>2.启动所有redis例程</h3><p>1）由于一个启动太麻烦，所以在这里创建一个批量启动redis中断的脚本文件startall.sh，文件内容如下：</p>
<p>cd redis01<br>./redis-server redis.conf<br>cd ..<br>cd redis02<br>./redis-server redis.conf<br>cd ..<br>cd redis03<br>./redis-server redis.conf<br>cd ..<br>cd redis04<br>./redis-server redis.conf<br>cd ..<br>cd redis05<br>./redis-server redis.conf<br>cd ..<br>cd redis06<br>./redis-server redis.conf<br>cd ..<br>16.png</p>
<p>2）创建好启动脚本文件之后，需要修改该脚本的权限，使之能够执行，指令如下：</p>
<p>chmod +x startall.sh<br>3）执行startall.sh脚本，启动6个redis例程</p>
<p>注意：如果出现报“没有那个文件或目录行”的错误，有可能是因为文件格式错误。输入如下命令将文件dos格式转换成unix再启动</p>
<p>dos2unix startall.sh<br>17.png</p>
<p>4）查看redis是否启动</p>
<p>ps -ef|grep redis<br>18.png</p>
<h3 id="3-安装Ruby环境"><a href="#3-安装Ruby环境" class="headerlink" title="3.安装Ruby环境"></a>3.安装Ruby环境</h3><p>注意：redis需要Ruby版本大于2.2.2</p>
<p>下载文件ruby-2.3.0.tar.gz</p>
<p>1）若存在Ruby，则清除旧版Ruby</p>
<p>yum remove ruby<br>2）安装依赖</p>
<p>yum -y install zlib-devel curl-devel openssl-devel httpd-devel apr-devel apr-util-devel mysql-devel<br>3）上传ruby-2.3.0到服务器，并解压</p>
<p>tar zxvf ruby-2.3.0.tar.gz<br>19.png</p>
<p>4）进入ruby-2.3.0目录下，执行以下命令</p>
<p>./configure –disable-install-rdoc<br>20.png</p>
<p>5）在ruby-2.3.0目录下，执行以下命令</p>
<p> make<br> make install<br>6）查看Ruby信息</p>
<p>ruby -v<br>21.png</p>
<p>7）要支持redis通信，需要下载redis相关包</p>
<p>gem install redis<br>22.png</p>
<h3 id="4-完善实力"><a href="#4-完善实力" class="headerlink" title="4.完善实力"></a>4.完善实力</h3><p>1）切换到redis解压的原始包src目录下</p>
<p>cd /root/redis-3.0.0/src/<br>2）执行以下命令</p>
<p>./redis-trib.rb create –replicas 1 192.168.0.40:6380 192.168.0.40:6381 192.168.0.40:6382 192.168.0.40:6383 192.168.0.40:6384 192.168.0.40:6385<br>–replicas 1 表示每个主数据库拥有从数据库个数为1。master节点不能少于3个，所以我们用了6个redis<br>23.png</p>
<p>3）遇到以下提示信息，手动输入是</p>
<p>24.png</p>
<h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h3><p>1）测试连接</p>
<p>./redis-cli -c -p 6380<br>25.png</p>
<p>2）查看所需信息</p>
<p>a.查看当前集群信息<br>cluster info<br>b.查看集群里有多少个节点<br>cluster nodes<br>26.png</p>
<h3 id="6-至此linux下redis部署安装完毕"><a href="#6-至此linux下redis部署安装完毕" class="headerlink" title="6.至此linux下redis部署安装完毕"></a>6.至此linux下redis部署安装完毕</h3><h3 id="7-建造多台遇到的问题"><a href="#7-建造多台遇到的问题" class="headerlink" title="7.建造多台遇到的问题"></a>7.建造多台遇到的问题</h3><p>配置文件<br>redis.conf<br>bind 127.0.0.1 机器ip<br>将绑定方式修改为:<br>bind 机器ip<br>开启集群的配置<br>#cluster-config-file nodes-6496.conf 将注释打开并将端口号修改，区别自动生成的文件<br>b问题<br>Redis集群端口为6491-6496 就需要打开6491-6496的端口号以及16491-16496的端口<br>c重启服务<br>重启服务需要将各个端口生成的rdb、nodes.conf 、aof文件删除<br>d验证<br>#./redis-cli -c -h 10.10.200.199 -p 6491<br>10.10.200.199:6491&gt;cluster nodes<br>10.10.200.199:6491&gt;cluster info<br>e查询键<br>查看key对应的slot<br>cluster keyslot key<br>查看slot和节点的对应关系<br>cluster slots<br>f关闭redis端口<br>./redis-cli -p 6379 shutdown<br>用kill -9 进程号，直接杀进程的方法会造成数据丢失<br>##后续### 1.redis-4.0.11默认会开启绑定127.0.0.1和写保护protected-mode是，配置的时候需要将bind 127.0.0.1注掉，改成protected-mode否</p>
]]></content>
      <categories>
        <category>NOSQL数据库</category>
      </categories>
      <tags>
        <tag>我的技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构</title>
    <url>/2014/02/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2020/08/17/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一亿数据获取前1000个最大值"><a href="#一亿数据获取前1000个最大值" class="headerlink" title="一亿数据获取前1000个最大值"></a>一亿数据获取前1000个最大值</h2><p> ###算法原理：</p>
<p>把一亿个数字的前100个 首先放入数组。 然后把最小值放在ary[0]。</p>
<p>然后再循环100到一亿之间的。 每次循环判断当前数字是否大于ary[0]</p>
<p>当大于时，当前数字放入ary[0] 并再次重构数组最小值进入ary[0]  以此类推 。</p>
<p>当循环完这一亿个数字后。 最大的前100个数字就出来了。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发设计</title>
    <url>/2017/03/12/%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="系统性能两大核心点"><a href="#系统性能两大核心点" class="headerlink" title="系统性能两大核心点"></a>系统性能两大核心点</h2><p>吞吐量（Throughput）<br>响应延迟（Response Delay）<br>优化目标<br>缩短响应时间<br>提供并发数<br>让系统处于合理状态<br>Number of Concurrent Users<br>上图是高并发软件性能模型。图中三条曲线，分别表示：</p>
<p>资源的利用情况（Utilization，包括硬件资源和软件资源）<br>吞吐量（Throughput，这里是指每秒事务数）<br>响应时间（Response Time）。<br>坐标轴的横轴从左到右表现了并发用户数（Number of Concurrent Users）的不断增长。</p>
<p>随着并发用户数的增长，资源占用率和吞吐量会相应的增长，但是响应时间的变化不大；不过当并发用户数增长到一定程度后，资源占用达到饱和，吞吐量增长明显放缓甚至停止增长，而响应时间却进一步延长。如果并发用户数继续增长，你会发现软硬件资源占用继续维持在饱和状态，但是吞吐量开始下降，响应时间明显的超出了用户可接受的范围，并且最终导致用户放弃了这次请求甚至离开。</p>
<p>根据这种性能表现，图中划分了三个区域，分别是</p>
<p>Light Load（较轻的压力）<br>Heavy Load（较重的压力）<br>Buckle Zone（用户无法忍受并放弃请求）。<br>在Light Load和Heavy Load两个区域交界处的并发用户数，我们称为“最佳并发用户数（The Optimum Number of Concurrent Users）”，而Heavy Load和Buckle Zone两个区域交界处的并发用户数则称为“最大并发用户数（The Maximum Number of Concurrent Users）”。 当系统的负载等于最佳并发用户数时，系统的整体效率最高，没有资源被浪费，用户也不需要等待；当系统负载处于最佳并发用户数和最大并发用户数之间时，系统可以继续工作，但是用户的等待时间延长，满意度开始降低，并且如果负载一直持续，将最终会导致有些用户无法忍受而放弃；而当系统负载大于最大并发用户数时，将注定会导致某些用户无法忍受超长的响应时间而放弃。</p>
<p>所以我们性能优化的目标就是让系统保持在Heavy Load（较重的压力） 区域。</p>
<h2 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h2><h3 id="1-空间换时间"><a href="#1-空间换时间" class="headerlink" title="1. 空间换时间"></a>1. 空间换时间</h3><p>系统时间是瓶颈。</p>
<p>这种情况是CPU处理时间很当，但是空间费用我们能接受，所以我们解决的问题的方法就是用空间来换时间。</p>
<p>例如：缓存复用计算结果，降低时间开销，因为CPU时间较内存容量更昂贵</p>
<h3 id="2-时间换空间"><a href="#2-时间换空间" class="headerlink" title="2. 时间换空间"></a>2. 时间换空间</h3><p>数据大小是瓶颈。</p>
<p>这种情况是空间占用很大，处理时间能接受，所以我们解决问题的方法就是用时间换空间。</p>
<p>例如1：网络传输是瓶颈，使用系统时间换取传输的空间，使用HTTP的gzip压缩算法。解压缩的时候会消耗CPU处理时间。<br>例如2：APP的请求分类接口，使用版本号判断哪些数据更新，只下载更新的数据。比如一些商品分类类目、城市列表等，一般很少会更新，可以缓存到本地，不能每次登录的时候都去拉取，所以针对这些数据我们可以做一个版本号，如果发现更新了就去拉取数据更新。再比如一些IM社交软件的用户列表，每次登录的时候都去拉一次，其实大家想想每次录的时候都是拉一次挺消耗网络流量的。而这个时候往往你的QQ好友列表变化并不是特别频繁，这个时候怎么办呢？我们会在这个QQ好友的列表有一个时间戳作为版本号，这个版本号在server端存一份，client端存一份，在每次登录的时候会先去判断一下这个版本号是否一致，如果不一致再做更新。</p>
<h3 id="3-找到系统瓶颈"><a href="#3-找到系统瓶颈" class="headerlink" title="3. 找到系统瓶颈"></a>3. 找到系统瓶颈</h3><p>分析系统业务流程，找到关键路径并分解优化。</p>
<p>一个服务集群4W的QPS，调用量前5的接口贡献了3.5W的QPS<br>对关键路径的代码优化收益最大，当然系统剩下的部分收益也不能忽视，比如剩下5k QPS接口若性能有问题也可能把整体服务性能拖垮。<br>所以我们需要抓主要矛盾。大概解决思路总结如下：</p>
<p>整个请求服务调了多少RPC接口；<br>载入多少数据；<br>使用什么算法；<br>非核心流程能否异步化；<br>没有数据依赖的逻辑能否并行执行<br>优化层次<br>从整体到细节，从全局角度到局部视角</p>
<h4 id="1-架构设计层次"><a href="#1-架构设计层次" class="headerlink" title="1. 架构设计层次"></a>1. 架构设计层次</h4><p>关注系统控制、数据流程<br>如何拆分系统，如何使各部分系统整体负载更加均衡，充分发挥硬件设施性能优势，减少系统内部开销等。<br>架构设计层次实现手段：</p>
<p>分布式系统微服务化<br>分库分表，读写分离，数据分片<br>无状态化设计，动态水平弹性扩展<br>调用连路梳理，热点数据尽量靠近用户<br>分布式Cache、多级多类型缓存<br>容量规划<br>提前拒绝，保证柔性可用</p>
<h4 id="2-算法逻辑层次"><a href="#2-算法逻辑层次" class="headerlink" title="2. 算法逻辑层次"></a>2. 算法逻辑层次</h4><p>算法选择是否高效，是否使时间优先级的还是空间优先级，算法逻辑优化，空间时间优化任务并行处理，使用无锁数据结构等。<br>空间换时间<br>ThreadLocal<br>时间换空间<br>采用压缩算法压缩数据，更复杂的逻辑减少数据传输</p>
<h2 id="2-1-算法逻辑优化层次实现细节"><a href="#2-1-算法逻辑优化层次实现细节" class="headerlink" title="2.1 算法逻辑优化层次实现细节"></a>2.1 算法逻辑优化层次实现细节</h2><p>用更高效的算法替换现有算法，而不改变其接口</p>
<p>增量式算法、复用之前的计算结果，比如一个报表服务，要从全量数据中生成报表数据量很大，但是每次增量的数据较少，则可以考虑只计算增量数据和之前计算结果合并。这样处理的数据量就小很多。</p>
<p>并发和锁的优化，读多写少的业务场景下，基于CAS的LockFree比Mutex性能更好</p>
<p>当系统时间是瓶颈，采取空间换时间逻辑算法，分配更多空间节省系统时间</p>
<p>缓存复用计算结果，降低时间开销，CPU时间较内存容量更加昂贵</p>
<p>当系统空间容量是瓶颈的时候，采用时间换空间算法策略</p>
<p>网络传输是瓶颈，使用系统时间换取空间的压缩，HTTP的gzip的压缩算法</p>
<p>APP的请求分类接口，使用版本号判断那些数据更新，只下载更新的数据，使用更多的代码逻辑处理更细颗粒度的数据</p>
<p>并行执行，比如一段逻辑调用了多个RPC接口，而这些接口之间并没有数据依赖，则可以考虑并行调用，降低响应时间。</p>
<p>异步执行，分析业务流程中的主次流程，把次要流程拆分出来异步执行，更进一步可以拆分到单独的模块去执行，比如使用消息队列，彻底和核心流程解耦，提高核心流程的稳定性以及降低响应是时间。</p>
<ol start="3">
<li>代码优化层次<br>关注代码细节优化，代码实现是否合理，是否创建了过多的对象，循环遍历是否高效，cache使用的是否合理，是否重用计算结果等。<h2 id="3-1-代码优化层次实现细节"><a href="#3-1-代码优化层次实现细节" class="headerlink" title="3.1 代码优化层次实现细节"></a>3.1 代码优化层次实现细节</h2>循环遍历是否合理高效，不要在循环里调用RPC接口、查询分布式缓存、执行SQL等<br>先调批量接口组装好数据、再循环处理<br>代码逻辑避免生成过多对象和无效对象<br>输出log时候的log级别判断，避免new无效对象<br>ArrayList、HashMap初始容量设置是否合理<br>扩容代价<br>对数据对象是否合理重用，比如通过RPC查到的数据能复用则必须复用<br>根据数据访问特性选择合适数据结构，比如读多写少，考虑CopyOnWriteArrayList(写时Copy副本)<br>拼接字符串的时候是使用String相加还是使用StringBuilder进行append(在StringBuilder的容量预分配的情况下StringBuilder的性能比String相加性能高15倍左右)<br>是否正确初始化数据。有些全局共享的数据，饿汉式模式，在用户访问之前先初始化好<h2 id="3-2-数据库代码优化层次实现细节"><a href="#3-2-数据库代码优化层次实现细节" class="headerlink" title="3.2 数据库代码优化层次实现细节"></a>3.2 数据库代码优化层次实现细节</h2>数据库建表语句使用尽量小的数据结构<br>表示状态的字段，如果状态值在255以内使用unsigned tinyint，IP使用int而非varchar<br>使用enum的场景使用tinyint替代，enum扩展需要该表<br>避免使用select * 查询语句，只查询需要的字段，避免浪费数据IO、内存、CPU、网络传输<br>分析查询场景经理合适的索引，分析字段的可选择性，索引长度，对长的varchar使用前缀索引<br>字段尽量为Not NULL类型，MySQL手册说吗允许NULL的字段需要额外的存储空间去处理NULL ，并且很难查询优化<br>以上优化的目的为了降低服务器CPU使用率、IO流量、内存占用、网络消耗、降低响应时间</li>
</ol>
<p>在做查询时，可以通过代码逻辑，加一下查询条件，利用索引来提升查询速度。</p>
<h2 id="3-3-局部优化层次实现细节"><a href="#3-3-局部优化层次实现细节" class="headerlink" title="3.3 局部优化层次实现细节"></a>3.3 局部优化层次实现细节</h2><p>以下两段代码哪个执行速度快？</p>
<p>long[][] a = new long[10000][10000];<br>    for(int i=0;i&lt;a.length;i++){<br>        for(int j =0;j&lt;a[i].length;j++){<br>            a[i][j]=j;<br>        }<br>    }<br>复制代码<br>long[][] a = new long[10000][10000];<br>    for(int i=0;i&lt;a.length;i++){<br>        for(int j =0;j&lt;a[i].length;j++){<br>            a[j][j]=j;<br>        }<br>    }<br>复制代码<br>这两段代码，唯一的区别在于填充方式，第一种方式是按行填充，第二种方式是按列进行填充。显然是第一种方式更快一些。 虽然是二维数组，但是在内存堆列中还一维数组进行存储的。大家可以在试一下，第一种运行速度比第二种方式快20倍。</p>
<p>那深层次原因是什么呢？</p>
<p>我们知道在计算机体系中，除了有内存来做缓存，在CPU层面也有cache结构。而越靠近CPU读取速度越快。如下图：</p>
<p>缓存的结构大概时这样的，从1级到3级速度越来越慢，最后通过总线与内存连接。 本质上内存是一个大的一维数组，二维数组在内存中按行排列，现存放a[0]行，再存放a[1]行，第一种遍历方式，是行遍历，先遍历完一行再遍历第二行，符合局部性原理，Cache Hit(缓存命中率高)，第二行遍历方式，是列遍历，遍历完第一列遍历第二列，由于下一列和上一列的数组元素在内存中并不是连续的，很可能导致Cache Miss（缓存未命中），CPU需要去内存载入数据，速度较CPU L1 Cache的速度降低了很多（主存100ns,L1cache 0.5ns）</p>
<p>扩大到一般场景，业务系统使用缓存降低响应时间提高性能，必须提高缓存命中率。很聚焦的高频访问，时效性要求不高很适合缓存提升性能，很聚焦的高频访问业务如banner，广告位，时效性要求不是特别高，比如更新了可以不用实时体现，很适合使用缓存提升性能。</p>
<p>如果对数据实时性要求很高，比如严格的时效性，需要慎重考虑更新缓存带来一致性问题。</p>
<p>时效性和缓存的冲突，比如商品服务对商品进行了缓存，由于更新缓存和更新商品不是同一个事务，则对数据时效性要求高的如交易，就只能直接从数据库查商品信息。</p>
]]></content>
      <categories>
        <category>高并发</category>
      </categories>
      <tags>
        <tag>java高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程</title>
    <url>/2015/04/12/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1.创建线程"></a>1.创建线程</h2><p>在Java中创建线程有两种方法：使用Thread类和使用Runnable接口。在使用Runnable接口时需要建立一个Thread实例。因此，无论是通过Thread类还是Runnable接口建立线程，都必须建立Thread类或它的子类的实例。Thread构造函数：</p>
<p>public Thread( );<br>public Thread(Runnable target);<br>public Thread(String name);<br>public Thread(Runnable target, String name);<br>public Thread(ThreadGroup group, Runnable target);<br>public Thread(ThreadGroup group, String name);<br>public Thread(ThreadGroup group, Runnable target, String name);<br>public Thread(ThreadGroup group, Runnable target, String name, long stackSize);<br> ###方法一：继承Thread类覆盖run方法</p>
<p>public class ThreadDemo1 {<br>     public static void main(String[] args){<br>         Demo d = new Demo();<br>         d.start();<br>         for(int i=0;i&lt;60;i++){<br>             System.out.println(Thread.currentThread().getName()+i);<br>         }</p>
<pre><code> &#125;</code></pre>
<p> }<br> class Demo extends Thread{<br>     public void run(){<br>         for(int i=0;i&lt;60;i++){<br>             System.out.println(Thread.currentThread().getName()+i);<br>         }<br>     }<br> }</p>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>public class ThreadDemo2 {<br>    public static void main(String[] args){<br>        Demo2 d =new Demo2();<br>        Thread t = new Thread(d);<br>        t.start();<br>        for(int x=0;x&lt;60;x++){<br>            System.out.println(Thread.currentThread().getName()+x);<br>        }<br>    }<br>}<br>class Demo2 implements Runnable{<br>    public void run(){<br>        for(int x=0;x&lt;60;x++){<br>            System.out.println(Thread.currentThread().getName()+x);<br>        }<br>    }<br>}</p>
<h2 id="2-线程的生命周期"><a href="#2-线程的生命周期" class="headerlink" title="2.线程的生命周期"></a>2.线程的生命周期</h2><p>与人有生老病死一样，线程也同样要经历开始（等待）、运行、挂起和停止四种不同的状态。这四种状态都可以通过Thread类中的方法进行控制。下面给出了Thread类中和这四种状态相关的方法。</p>
<p>// 开始线程<br>publicvoid start( );<br>publicvoid run( );<br>// 挂起和唤醒线程<br>publicvoid resume( ); // 不建议使用<br>publicvoid suspend( ); // 不建议使用<br>publicstaticvoid sleep(long millis);<br>publicstaticvoid sleep(long millis, int nanos);<br>// 终止线程<br>publicvoid stop( ); // 不建议使用<br>publicvoid interrupt( );<br>// 得到线程状态<br>publicboolean isAlive( );<br>publicboolean isInterrupted( );<br>publicstaticboolean interrupted( );<br>// join方法<br>publicvoid join( ) throws InterruptedException;<br>线程在建立后并不马上执行run方法中的代码，而是处于等待状态。线程处于等待状态时，可以通过Thread类的方法来设置线程不各种属性，如线程的优先级（setPriority）、线程名(setName)和线程的类型（setDaemon）等。</p>
<p>当调用start方法后，线程开始执行run方法中的代码。线程进入运行状态。可以通过Thread类的isAlive方法来判断线程是否处于运行状态。当线程处于运行状态时，isAlive返回true，当isAlive返回false时，可能线程处于等待状态，也可能处于停止状态。下面的代码演示了线程的创建、运行和停止三个状态之间的切换，并输出了相应的isAlive返回值。</p>
<p>一但线程开始执行run方法，就会一直到这个run方法执行完成这个线程才退出。但在线程执行的过程中，可以通过两个方法使线程暂时停止执行。这两个方法是suspend和sleep。在使用suspend挂起线程后，可以通过resume方法唤醒线程。而使用sleep使线程休眠后，只能在设定的时间后使线程处于就绪状态（在线程休眠结束后，线程不一定会马上执行，只是进入了就绪状态，等待着系统进行调度）。</p>
<p>在使用sleep方法时有两点需要注意：</p>
<h3 id="1-sleep方法有两个重载形式，其中一个重载形式不仅可以设毫秒，而且还可以设纳秒-1-000-000纳秒等于1毫秒-。但大多数操作系统平台上的Java虚拟机都无法精确到纳秒，因此，如果对sleep设置了纳秒，Java虚拟机将取最接近这个值的毫秒。"><a href="#1-sleep方法有两个重载形式，其中一个重载形式不仅可以设毫秒，而且还可以设纳秒-1-000-000纳秒等于1毫秒-。但大多数操作系统平台上的Java虚拟机都无法精确到纳秒，因此，如果对sleep设置了纳秒，Java虚拟机将取最接近这个值的毫秒。" class="headerlink" title="1. sleep方法有两个重载形式，其中一个重载形式不仅可以设毫秒，而且还可以设纳秒(1,000,000纳秒等于1毫秒)。但大多数操作系统平台上的Java虚拟机都无法精确到纳秒，因此，如果对sleep设置了纳秒，Java虚拟机将取最接近这个值的毫秒。"></a>1. sleep方法有两个重载形式，其中一个重载形式不仅可以设毫秒，而且还可以设纳秒(1,000,000纳秒等于1毫秒)。但大多数操作系统平台上的Java虚拟机都无法精确到纳秒，因此，如果对sleep设置了纳秒，Java虚拟机将取最接近这个值的毫秒。</h3><h3 id="2-在使用sleep方法时必须使用throws或try-…-catch-…-。因为run方法无法使用throws，所以只能使用try-…-catch-…-。当在线程休眠的过程中，使用interrupt方法中断线程时sleep会抛出一个InterruptedException异常。sleep方法的定义如下："><a href="#2-在使用sleep方法时必须使用throws或try-…-catch-…-。因为run方法无法使用throws，所以只能使用try-…-catch-…-。当在线程休眠的过程中，使用interrupt方法中断线程时sleep会抛出一个InterruptedException异常。sleep方法的定义如下：" class="headerlink" title="2. 在使用sleep方法时必须使用throws或try{…}catch{…}。因为run方法无法使用throws，所以只能使用try{…}catch{…}。当在线程休眠的过程中，使用interrupt方法中断线程时sleep会抛出一个InterruptedException异常。sleep方法的定义如下："></a>2. 在使用sleep方法时必须使用throws或try{…}catch{…}。因为run方法无法使用throws，所以只能使用try{…}catch{…}。当在线程休眠的过程中，使用interrupt方法中断线程时sleep会抛出一个InterruptedException异常。sleep方法的定义如下：</h3><p>publicstaticvoid sleep(long millis) throws InterruptedException<br>publicstaticvoid sleep(long millis, int nanos) throws InterruptedException<br>有三种方法可以使终止线程。</p>
<ol>
<li><p>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。</p>
</li>
<li><p>使用stop方法强行终止线程（这个方法不推荐使用，因为stop和suspend、resume一样，也可能发生不可预料的结果）。</p>
</li>
<li><p>使用interrupt方法中断线程。</p>
</li>
<li><p>使用退出标志终止线程</p>
</li>
</ol>
<p>当run方法执行完后，线程就会退出。但有时run方法是永远不会结束的。如在服务端程序中使用线程进行监听客户端请求，或是其他的需要循环处理的任务。在这种情况下，一般是将这些任务放在一个循环中，如while循环。如果想让循环永远运行下去，可以使用while(true){…}来处理。但要想使while循环在某一特定条件下退出，最直接的方法就是设一个boolean类型的标志，并通过设置这个标志为true或false来控制while循环是否退出。下面给出了一个利用退出标志终止线程的例子。</p>
<p>join方法的功能就是使异步执行的线程变成同步执行。也就是说，当调用线程实例的start方法后，这个方法会立即返回，如果在调用start方法后后需要使用一个由这个线程计算得到的值，就必须使用join方法。如果不使用join方法，就不能保证当执行到start方法后面的某条语句时，这个线程一定会执行完。而使用join方法后，直到这个线程退出，程序才会往下执行。下面的代码演示了join的用法。</p>
<h2 id="3-多线程安全问题"><a href="#3-多线程安全问题" class="headerlink" title="3.多线程安全问题"></a>3.多线程安全问题</h2><p>问题原因：当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没执行完，另一个线程参与进来执行，导致共享数据的错误。</p>
<p>解决办法：对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不执行。</p>
<h4 id="同步代码块："><a href="#同步代码块：" class="headerlink" title="同步代码块："></a>同步代码块：</h4><p>public class ThreadDemo3 {<br>    public static void main(String[] args){<br>        Ticket t =new Ticket();<br>        Thread t1 = new Thread(t,”窗口一”);<br>        Thread t2 = new Thread(t,”窗口二”);<br>        Thread t3 = new Thread(t,”窗口三”);<br>        Thread t4 = new Thread(t,”窗口四”);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br>        t4.start();<br>    }<br>}<br>class Ticket implements Runnable{<br>    private int ticket =400;<br>    public void run(){<br>        while(true){<br>            synchronized (new Object()) {<br>                try {<br>                    Thread.sleep(1);<br>                } catch (InterruptedException e) {<br>                    // TODO Auto-generated catch block<br>                    e.printStackTrace();<br>                }<br>                if(ticket&lt;=0)<br>                    break;<br>                System.out.println(Thread.currentThread().getName()+”—卖出”+ticket–);<br>            }<br>        }<br>    }<br>}<br>同步函数</p>
<p>public class ThreadDemo3 {<br>    public static void main(String[] args){<br>        Ticket t =new Ticket();<br>        Thread t1 = new Thread(t,”窗口一”);<br>        Thread t2 = new Thread(t,”窗口二”);<br>        Thread t3 = new Thread(t,”窗口三”);<br>        Thread t4 = new Thread(t,”窗口四”);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br>        t4.start();<br>    }<br>}<br>class Ticket implements Runnable{<br>    private int ticket = 4000;<br>    public synchronized void  saleTicket(){<br>        if(ticket&gt;0)<br>            System.out.println(Thread.currentThread().getName()+”卖出了”+ticket–);</p>
<pre><code>&#125;
public void run()&#123;
    while(true)&#123;
        saleTicket();
    &#125;
&#125;</code></pre>
<p>}<br>同步函数锁是this 静态同步函数锁是class</p>
<h4 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h4><p>public class ThreadDemo3 {<br>    public static void main(String[] args){<br>        class Person{<br>            public String name;<br>            private String gender;<br>            public void set(String name,String gender){<br>                this.name =name;<br>                this.gender =gender;<br>            }<br>            public void get(){<br>                System.out.println(this.name+”….”+this.gender);<br>            }<br>        }<br>        final Person p =new Person();<br>        new Thread(new Runnable(){<br>            public void run(){<br>                int x=0;<br>                while(true){<br>                    if(x==0){<br>                        p.set(“张三”, “男”);<br>                    }else{<br>                        p.set(“lili”, “nv”);<br>                    }<br>                    x=(x+1)%2;<br>                }<br>            }<br>        }).start();<br>        new Thread(new Runnable(){<br>            public void run(){<br>                while(true){<br>                    p.get();<br>                }<br>            }<br>        }).start();<br>    }<br>}<br>/*<br>张三….男<br>张三….男<br>lili….nv<br>lili….男<br>张三….nv<br>lili….男<br>*/<br>修改上面代码</p>
<p>public class ThreadDemo3 {<br>     public static void main(String[] args){<br>         class Person{<br>             public String name;<br>             private String gender;<br>             public void set(String name,String gender){<br>                 this.name =name;<br>                 this.gender =gender;<br>             }<br>             public void get(){<br>                 System.out.println(this.name+”….”+this.gender);<br>             }<br>         }<br>         final Person p =new Person();<br>         new Thread(new Runnable(){<br>             public void run(){<br>                 int x=0;<br>                 while(true){<br>                     synchronized (p) {<br>                         if(x==0){<br>                             p.set(“张三”, “男”);<br>                         }else{<br>                             p.set(“lili”, “nv”);<br>                         }<br>                         x=(x+1)%2;<br>                     }</p>
<pre><code>             &#125;
         &#125;
     &#125;).start();
     new Thread(new Runnable()&#123;
         public void run()&#123;
             while(true)&#123;
                 synchronized (p) &#123;
                     p.get();
                 &#125;
             &#125;
         &#125;
     &#125;).start();
 &#125;</code></pre>
<p> }<br> /*<br> lili….nv<br> lili….nv<br> lili….nv<br> lili….nv<br> lili….nv<br> lili….nv<br> 张三….男<br> 张三….男<br> 张三….男<br> 张三….男<br> */</p>
<h4 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h4><p>/*<br> *线程等待唤醒机制<br> *等待和唤醒必须是同一把锁<br> */<br>public class ThreadDemo3 {<br>    private static boolean flags =false;<br>    public static void main(String[] args){<br>        class Person{<br>            public String name;<br>            private String gender;<br>            public void set(String name,String gender){<br>                this.name =name;<br>                this.gender =gender;<br>            }<br>            public void get(){<br>                System.out.println(this.name+”….”+this.gender);<br>            }<br>        }<br>        final Person p =new Person();<br>        new Thread(new Runnable(){<br>            public void run(){<br>                int x=0;<br>                while(true){<br>                    synchronized (p) {<br>                        if(flags)<br>                            try {<br>                                p.wait();<br>                            } catch (InterruptedException e) {<br>                                // TODO Auto-generated catch block<br>                                e.printStackTrace();<br>                            };<br>                        if(x==0){<br>                            p.set(“张三”, “男”);<br>                        }else{<br>                            p.set(“lili”, “nv”);<br>                        }<br>                        x=(x+1)%2;<br>                        flags =true;<br>                        p.notifyAll();<br>                    }<br>                }<br>            }<br>        }).start();<br>        new Thread(new Runnable(){<br>            public void run(){<br>                while(true){<br>                    synchronized (p) {<br>                        if(!flags)<br>                            try {<br>                                p.wait();<br>                            } catch (InterruptedException e) {<br>                                // TODO Auto-generated catch block<br>                                e.printStackTrace();<br>                            };<br>                        p.get();<br>                        flags =false;<br>                        p.notifyAll();<br>                        }<br>                }<br>            }<br>        }).start();<br>    }<br>}</p>
<h4 id="生产消费机制一"><a href="#生产消费机制一" class="headerlink" title="生产消费机制一"></a>生产消费机制一</h4><p>public class ThreadDemo4 {<br>    private static boolean flags =false;<br>    public static void main(String[] args){<br>        class Goods{<br>            private String name;<br>            private int num;<br>            public synchronized void produce(String name){<br>                if(flags)<br>                    try {<br>                        wait();<br>                    } catch (InterruptedException e) {<br>                        // TODO Auto-generated catch block<br>                        e.printStackTrace();<br>                    }<br>                this.name =name+”编号：”+num++;<br>                System.out.println(“生产了….”+this.name);<br>                flags =true;<br>                notifyAll();<br>            }<br>            public synchronized void consume(){<br>                if(!flags)<br>                    try {<br>                        wait();<br>                    } catch (InterruptedException e) {<br>                        // TODO Auto-generated catch block<br>                        e.printStackTrace();<br>                    }<br>                System.out.println(“消费了******”+name);<br>                flags =false;<br>                notifyAll();<br>            }</p>
<pre><code>    &#125;
    final Goods g =new Goods();
    new Thread(new Runnable()&#123;
        public void run()&#123;
            while(true)&#123;
                g.produce(&quot;商品&quot;);
            &#125;
        &#125;
    &#125;).start();
    new Thread(new Runnable()&#123;
        public void run()&#123;
            while(true)&#123;
                g.consume();
            &#125;
        &#125;
    &#125;).start();
&#125;</code></pre>
<p>}</p>
<h4 id="生产消费机制2"><a href="#生产消费机制2" class="headerlink" title="生产消费机制2"></a>生产消费机制2</h4><p>public class ThreadDemo4 {<br>    private static boolean flags =false;<br>    public static void main(String[] args){<br>        class Goods{<br>            private String name;<br>            private int num;<br>            public synchronized void produce(String name){<br>                while(flags)<br>                    try {<br>                        wait();<br>                    } catch (InterruptedException e) {<br>                        // TODO Auto-generated catch block<br>                        e.printStackTrace();<br>                    }<br>                this.name =name+”编号：”+num++;<br>                System.out.println(Thread.currentThread().getName()+”生产了….”+this.name);<br>                flags =true;<br>                notifyAll();<br>            }<br>            public synchronized void consume(){<br>                while(!flags)<br>                    try {<br>                        wait();<br>                    } catch (InterruptedException e) {<br>                        // TODO Auto-generated catch block<br>                        e.printStackTrace();<br>                    }<br>                System.out.println(Thread.currentThread().getName()+”消费了******”+name);<br>                flags =false;<br>                notifyAll();<br>            }</p>
<pre><code>    &#125;
    final Goods g =new Goods();
    new Thread(new Runnable()&#123;
        public void run()&#123;
            while(true)&#123;
                g.produce(&quot;商品&quot;);
            &#125;
        &#125;
    &#125;,&quot;生产者一号&quot;).start();
    new Thread(new Runnable()&#123;
        public void run()&#123;
            while(true)&#123;
                g.produce(&quot;商品&quot;);
            &#125;
        &#125;
    &#125;,&quot;生产者二号&quot;).start();
    new Thread(new Runnable()&#123;
        public void run()&#123;
            while(true)&#123;
                g.consume();
            &#125;
        &#125;
    &#125;,&quot;消费者一号&quot;).start();
    new Thread(new Runnable()&#123;
        public void run()&#123;
            while(true)&#123;
                g.consume();
            &#125;
        &#125;
    &#125;,&quot;消费者二号&quot;).start();
&#125;</code></pre>
<p>}<br>/*<br>消费者二号消费了**<strong><strong>商品编号：48049<br>生产者一号生产了….商品编号：48050<br>消费者一号消费了**</strong></strong>商品编号：48050<br>生产者一号生产了….商品编号：48051<br>消费者二号消费了**<strong><strong>商品编号：48051<br>生产者二号生产了….商品编号：48052<br>消费者二号消费了**</strong></strong>商品编号：48052<br>生产者一号生产了….商品编号：48053<br>消费者一号消费了**<strong><strong>商品编号：48053<br>生产者一号生产了….商品编号：48054<br>消费者二号消费了**</strong></strong>商品编号：48054<br>生产者二号生产了….商品编号：48055<br>消费者二号消费了******商品编号：48055<br>*/</p>
]]></content>
      <categories>
        <category>java多线程</category>
      </categories>
      <tags>
        <tag>java多线程</tag>
      </tags>
  </entry>
</search>
